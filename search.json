[
  {
    "objectID": "posts/010-initial/index.html",
    "href": "posts/010-initial/index.html",
    "title": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application",
    "section": "",
    "text": "We want to create a data portal application where users can pick data sets to be joined together and filters to filter the data. The final application will have the following features:\nThis is a series of building a shiny application that serves as a reference for a larger and more complicated application. It also goes through implementing a solution, improving it, and refactoring it as we go. It comes from a series of 1:1 meeting’s with Joe Cheng on the Shiny team\nThink of this series as a “data scientist’s guide to thinking like a software engineer”."
  },
  {
    "objectID": "posts/010-initial/index.html#base-application",
    "href": "posts/010-initial/index.html#base-application",
    "title": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application",
    "section": "Base Application",
    "text": "Base Application\nWe’ll build on a small example dataframe using a sample of a generated tips data set. Some of the more complex decisions and features of the application we can put in place holder elements for\n\nThe data will come from a @reactive.calc and be a placeholder for a final joined dataframe\nAll the UI elements will eventually be created by a larger @render.ui call, so the UI elements will all be created in the server() function\n\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 500\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\napp_ui = ui.page_fixed(\n    ui.output_ui(\"table_day_filter\"), #&lt;&lt;\n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n\n    # filtered dataframe from filters #&lt;&lt;\n    @reactive.calc #&lt;&lt;\n    def data_filtered(): #&lt;&lt;\n        df = df_tips() #&lt;&lt;\n\n        if input.filter_day(): #&lt;&lt;\n            df = df.loc[df[\"day\"].isin(input.filter_day())] #&lt;&lt;\n\n        return df #&lt;&lt;\n\n    # dataframe to view in app\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\n    # table day filter #&lt;&lt;\n    @render.ui #&lt;&lt;\n    def table_day_filter(): #&lt;&lt;\n        return ui.input_selectize( #&lt;&lt;\n            \"filter_day\", #&lt;&lt;\n            \"table day filter:\", #&lt;&lt;\n            df_tips()[\"day\"].unique().tolist(), #&lt;&lt;\n            multiple=True, #&lt;&lt;\n            remove_button=True, #&lt;&lt;\n            options={\"plugins\": [\"clear_button\"]}, #&lt;&lt;\n        ) #&lt;&lt;\n\n    # placeholder for joined dataframe\n    @reactive.calc\n    def df_tips():\n        # fmt: off\n        data = {\n            'total_bill': [\n                16.99, 10.34, 21.01, 23.68, 24.59,\n                25.29, 8.77, 26.88, 15.04, 14.78\n            ],\n            'tip': [\n                1.01, 1.66, 3.50, 3.31, 3.61,\n                4.71, 2.00, 3.12, 3.52, 3.00\n            ],\n            'sex': [\n                'Female', 'Male', 'Male', 'Male', 'Female',\n                'Male', 'Male', 'Male', 'Male', 'Female'\n            ],\n            'smoker': [\n                'No', 'No', 'No', 'No', 'Yes',\n                'No', 'No', 'Yes', 'No', 'Yes'\n            ],\n            'day': [\n                'Sun', 'Fri', 'Sun', 'Thu', 'Sun',\n                'Sun', 'Sat', 'Sat', 'Sat', 'Sat'\n            ],\n            'time': [\n                'Dinner', 'Dinner', 'Lunch', 'Dinner', 'Lunch',\n                'Dinner', 'Lunch', 'Dinner', 'Lunch', 'Dinner'\n            ],\n            'size': [2, 3, 3, 2, 4, 4, 2, 4, 2, 2]\n        }\n        # fmt: on\n\n        df = pd.DataFrame(data)\n        return df\n\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "posts/010-initial/index.html#add-another-filter-component",
    "href": "posts/010-initial/index.html#add-another-filter-component",
    "title": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application",
    "section": "Add Another Filter Component",
    "text": "Add Another Filter Component\nLet’s go add another filter. We’ll keep things simple for now, and add a filter for a column of the same data type, time, a categorical variable stored as a string.\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 650\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\napp_ui = ui.page_fixed(\n    ui.output_ui(\"table_day_filter\"),\n    ui.output_ui(\"table_time_filter\"),\n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n\n    # filtered dataframe from filters\n    @reactive.calc\n    def data_filtered():\n        df = df_tips()\n\n        if input.filter_day(): #&lt;&lt;\n            df = df.loc[df[\"day\"].isin(input.filter_day())] #&lt;&lt;\n\n        if input.filter_time(): #&lt;&lt;\n            df = df.loc[df[\"time\"].isin(input.filter_time())] #&lt;&lt;\n\n        return df\n\n    # dataframe to view in app\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\n    # table day filter\n    @render.ui\n    def table_day_filter():\n        return ui.input_selectize(\n            \"filter_day\",\n            \"table day filter:\",\n            df_tips()[\"day\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # table time filter\n    @render.ui\n    def table_time_filter():\n        return ui.input_selectize(\n            \"filter_time\",\n            \"table time filter:\",\n            df_tips()[\"time\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # placeholder for joined dataframe\n    @reactive.calc\n    def df_tips():\n        # fmt: off\n        data = {\n            'total_bill': [\n                16.99, 10.34, 21.01, 23.68, 24.59,\n                25.29, 8.77, 26.88, 15.04, 14.78\n            ],\n            'tip': [\n                1.01, 1.66, 3.50, 3.31, 3.61,\n                4.71, 2.00, 3.12, 3.52, 3.00\n            ],\n            'sex': [\n                'Female', 'Male', 'Male', 'Male', 'Female',\n                'Male', 'Male', 'Male', 'Male', 'Female'\n            ],\n            'smoker': [\n                'No', 'No', 'No', 'No', 'Yes',\n                'No', 'No', 'Yes', 'No', 'Yes'\n            ],\n            'day': [\n                'Sun', 'Fri', 'Sun', 'Thu', 'Sun',\n                'Sun', 'Sat', 'Sat', 'Sat', 'Sat'\n            ],\n            'time': [\n                'Dinner', 'Dinner', 'Lunch', 'Dinner', 'Lunch',\n                'Dinner', 'Lunch', 'Dinner', 'Lunch', 'Dinner'\n            ],\n            'size': [2, 3, 3, 2, 4, 4, 2, 4, 2, 2]\n        }\n        # fmt: on\n\n        df = pd.DataFrame(data)\n        return df\n\n\napp = App(app_ui, server)\n\n\nAs we add more components, we have to add code to three locations in the code base:\n\nA new @render.ui function within the server() logic\nCalling the @render.ui within app_ui\nFiltering the dataframe within the server() logic, in this case specifically in the data_filtered() @reactive.calc\n\nWe will also want to be able to control the sorting of the filter drop down. At the moment the elements are presented in the order they appear in the data. We may want to sort them alphabetically, or in these two component examples, sort them based on time.\n\n\n\n\n\n\nThings to fix\n\n\n\n\nDifferent filter components may want options presented in different orders"
  },
  {
    "objectID": "posts/010-initial/index.html#how-best-to-subset-the-data",
    "href": "posts/010-initial/index.html#how-best-to-subset-the-data",
    "title": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application",
    "section": "How (Best) to Subset the Data",
    "text": "How (Best) to Subset the Data\nCurrently, we are passing our filter contents into an .loc[] row subsetting call in a series of if statements. This works just fine in our current simple example, but we know that in the future there will be more filters.\nYou can always add another layer of abstraction to a program, and have your code run “in a single line of code”. But, each layer of abstraction will make the code harder to reason with since you will have to look up the definition elsewhere to keep everything in your head. \nOn the other hand, the current code using a sequence of if statements is fairly easy to reason with, you can see what is being checked along the way and how the data is filtered, and everything is right in front of you. However, we know that eventually this code will have many more if statements and you can make the case of cyclomatic complexity to at least abstract away the conditional if statements away that is doing the data filtering.\nWe now run into the first big implementation decision in our application, we could systematically filter the dataframes by the values in the filter in a series of if statements, however, it would make our current data_filtered() @reactive.cal very long and complicated. It would be easier to track a row ID so we can deal with all the filters and then the data_filtered() would only need to filter based on the ID. This helps abstract away the complexity of the filtering we’ll be doing, and potentially open us up for any more complicated filtering we would want to do later on.\n\nImplementation Idea 1: Use an ID Column\nIn pandas we could create an ID column by resetting and using the .index.\ndf.reset_index().rename(columns={\"index\": \"id\"})\nWe can check or track whether a data set has an ID column already, and if it doesn’t we can create one. But, we do not want to modify the original datasets in this manner, since it will be displayed and eventually save the extra column we created. It also would make the application less general as a template, since it will force other users to always have an explicit ID column.\n\n\nImplementation Idea 2: Track the Row Name (Pandas Index)\nA better way would be to track the the “row name” for each observation we want to keep. pandas does not have a “row name” but the .index can be used as one. We can assume since we are not processing any data, and this application is mainly serving as a data explorer, resetting the index of the dataframe and using the .index as a means to track the “row name” would be a good way to go.\n\n\nTest the Concept\nWe want to capture the index of the rows that match the filter, but when we are doing our final subsetting, we want to filter based on the .loc[] not .iloc[]. This will make sure as we make successive filters, and if the data gets scrambled, we are still pulling the correct row by the “row name” identifier.\n\ndf.sample(frac=1, random_state=42)\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n8\n15.04\n3.52\nMale\nNo\nSat\nLunch\n2\n\n\n1\n10.34\n1.66\nMale\nNo\nFri\nDinner\n3\n\n\n5\n25.29\n4.71\nMale\nNo\nSun\nDinner\n4\n\n\n0\n16.99\n1.01\nFemale\nNo\nSun\nDinner\n2\n\n\n7\n26.88\n3.12\nMale\nYes\nSat\nDinner\n4\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nLunch\n3\n\n\n9\n14.78\n3.00\nFemale\nYes\nSat\nDinner\n2\n\n\n4\n24.59\n3.61\nFemale\nYes\nSun\nLunch\n4\n\n\n3\n23.68\n3.31\nMale\nNo\nThu\nDinner\n2\n\n\n6\n8.77\n2.00\nMale\nNo\nSat\nLunch\n2\n\n\n\n\n\n\n\n\nidx = [6, 2, 1, 9]\n\nIf we look at the index values from .loc[], it matches the indices we want to keep.\n\ndf.sample(frac=1, random_state=42).loc[idx]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n6\n8.77\n2.00\nMale\nNo\nSat\nLunch\n2\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nLunch\n3\n\n\n1\n10.34\n1.66\nMale\nNo\nFri\nDinner\n3\n\n\n9\n14.78\n3.00\nFemale\nYes\nSat\nDinner\n2\n\n\n\n\n\n\n\nIf we use .iloc[] we won’t filter the rows we want. We can potentially even run into an out of bounds index with .iloc[].\n\ndf.sample(frac=1, random_state=42).iloc[idx]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n9\n14.78\n3.00\nFemale\nYes\nSat\nDinner\n2\n\n\n5\n25.29\n4.71\nMale\nNo\nSun\nDinner\n4\n\n\n1\n10.34\n1.66\nMale\nNo\nFri\nDinner\n3\n\n\n6\n8.77\n2.00\nMale\nNo\nSat\nLunch\n2\n\n\n\n\n\n\n\n\n\n\n\n\n\nA good idea\n\n\n\nTrack the index of the rows we want to filter."
  },
  {
    "objectID": "posts/010-initial/index.html#filter-based-on-index-label",
    "href": "posts/010-initial/index.html#filter-based-on-index-label",
    "title": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application",
    "section": "Filter Based on Index Label",
    "text": "Filter Based on Index Label\nOne of the other benefits of tracking the index for filtering is we do not need to filter out data with the dataframe boolean bitwise filtering with .loc[] and &. At the point of filtering, we can just use the list of index values.\n\ndf.loc[(df.time.isin([\"Dinner\"])) & (df['size'].isin([4]))]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n5\n25.29\n4.71\nMale\nNo\nSun\nDinner\n4\n\n\n7\n26.88\n3.12\nMale\nYes\nSat\nDinner\n4\n\n\n\n\n\n\n\nIf we can create just the container of index values, the code at the point of filtering would look much simpler. We would only need to track the row index labels when subsetting the final dataframe, and the logic for how the index values were generated can be abstracted away. This potentially opens us up for the ability to do any more complex filtering later on since only need to provide a list of index labels.\n\nidx = [5, 7] # creating this can be as complex as we need\ndf.loc[idx]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n5\n25.29\n4.71\nMale\nNo\nSun\nDinner\n4\n\n\n7\n26.88\n3.12\nMale\nYes\nSat\nDinner\n4\n\n\n\n\n\n\n\n\nCreate List of Indices\nNow, how do we create this list of indices? If we were doing the filtering one column at a time, we would be using the & operator across all the filters (see the code example above). We now need the equivalent of this on a list. We will separately get a list of indices that match the filter, and then filter down each list for values that match. In set theory, this is an intersect.\nWe will create a new @reactive.calc called filter_idx() that will perform the same if statement checks as we did before. The difference now is at the point where the data is filtered, we only need to know that we’re filtering based on all the index labels that matched the filter.\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 650\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\napp_ui = ui.page_fixed(\n    ui.output_ui(\"table_day_filter\"),\n    ui.output_ui(\"table_time_filter\"),\n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n\n    @reactive.calc #&lt;&lt;\n    def filter_idx(): #&lt;&lt;\n        df = df_tips() #&lt;&lt;\n        idx = set(df.index) #&lt;&lt;\n\n        if input.filter_day(): #&lt;&lt;\n            current_idx = df.loc[df[\"day\"].isin(input.filter_day())].index #&lt;&lt;\n            idx = idx.intersection(set(current_idx)) #&lt;&lt;\n\n        if input.filter_time(): #&lt;&lt;\n            current_idx = df.loc[df[\"time\"].isin(input.filter_time())].index #&lt;&lt;\n            idx = idx.intersection(set(current_idx)) #&lt;&lt;\n\n        # convert to list because you get this error #&lt;&lt;\n        # when passing into .loc[] #&lt;&lt;\n        # TypeError: Passing a set as an indexer is not supported. Use a list instead. #&lt;&lt;\n        return list(idx) #&lt;&lt;\n\n\n    # filtered dataframe from filters\n    @reactive.calc\n    def data_filtered():\n        df = df_tips().loc[filter_idx()] #&lt;&lt;\n        return df\n\n    # dataframe to view in app\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\n    # table day filter\n    @render.ui\n    def table_day_filter():\n        return ui.input_selectize(\n            \"filter_day\",\n            \"table day filter:\",\n            df_tips()[\"day\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # table time filter\n    @render.ui\n    def table_time_filter():\n        return ui.input_selectize(\n            \"filter_time\",\n            \"table time filter:\",\n            df_tips()[\"time\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # placeholder for joined dataframe\n    @reactive.calc\n    def df_tips():\n        # fmt: off\n        data = {\n            'total_bill': [\n                16.99, 10.34, 21.01, 23.68, 24.59,\n                25.29, 8.77, 26.88, 15.04, 14.78\n            ],\n            'tip': [\n                1.01, 1.66, 3.50, 3.31, 3.61,\n                4.71, 2.00, 3.12, 3.52, 3.00\n            ],\n            'sex': [\n                'Female', 'Male', 'Male', 'Male', 'Female',\n                'Male', 'Male', 'Male', 'Male', 'Female'\n            ],\n            'smoker': [\n                'No', 'No', 'No', 'No', 'Yes',\n                'No', 'No', 'Yes', 'No', 'Yes'\n            ],\n            'day': [\n                'Sun', 'Fri', 'Sun', 'Thu', 'Sun',\n                'Sun', 'Sat', 'Sat', 'Sat', 'Sat'\n            ],\n            'time': [\n                'Dinner', 'Dinner', 'Lunch', 'Dinner', 'Lunch',\n                'Dinner', 'Lunch', 'Dinner', 'Lunch', 'Dinner'\n            ],\n            'size': [2, 3, 3, 2, 4, 4, 2, 4, 2, 2]\n        }\n        # fmt: on\n\n        df = pd.DataFrame(data)\n        return df\n\n\napp = App(app_ui, server)\n\n\n\n\nIterative Improvement\nNow that we’ve modified the current code to roughly the parts we want, let’s make a few code improvements.\nFirst, our new filter_idx() @reactive.calc still relies on a series of if statements. We want to eventually perform filters across all or an arbitrary number of columns and filter components, so we’d want to do the same if logic in a for loop. We will need to track the column name as well as the filter id used by Shiny.\nSecond, the way filter_idx() was implemented has a lot of data type changes and isn’t obvious what what type the idx variable is because the initial type is changed in the return statement, and used as if its an .index value. This makes the code extremely hard to reason with and maintain. We are expecting an index value, the initial idx variable is stored as a set so we can run .intersection(), but the return type is a list.\n\nThe way filter_idx() was implemented wasn’t written this way for pedagogical purposes. I really did write the code in this manner in the initial implementation.\n\nThe first issue is fixed by using a for loop and creating a few accompanying variables. The second issue can be fixed by taking another look through the pandas API reference and noticing that we did not actually need to use .intersection() on a set, the index object also has an .intersection() method! This means we can implement filter_idx() using only index objects.\n\n\n\n\n\n\nA good idea\n\n\n\nDo not change the data type of your variables during an implementation.\n\n\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 650\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\napp_ui = ui.page_fixed(\n    ui.output_ui(\"table_day_filter\"),\n    ui.output_ui(\"table_time_filter\"),\n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n\n    @reactive.calc\n    def filter_idx():\n        df = df_tips()\n        idx = df.index\n\n        filters = [\"filter_day\", \"filter_time\"] #&lt;&lt;\n        cols = [\"day\", \"time\"] #&lt;&lt;\n\n        for fltr, col in zip(filters, cols): #&lt;&lt;\n            if input[fltr](): #&lt;&lt;\n                current_idx = df.loc[df[col].isin(input[fltr]())].index #&lt;&lt;\n                idx = idx.intersection(current_idx) #&lt;&lt;\n\n        return idx #&lt;&lt;\n\n\n    # filtered dataframe from filters\n    @reactive.calc\n    def data_filtered():\n        df = df_tips().loc[filter_idx()]\n        return df\n\n    # dataframe to view in app\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\n    # table day filter\n    @render.ui\n    def table_day_filter():\n        return ui.input_selectize(\n            \"filter_day\",\n            \"table day filter:\",\n            df_tips()[\"day\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # table time filter\n    @render.ui\n    def table_time_filter():\n        return ui.input_selectize(\n            \"filter_time\",\n            \"table time filter:\",\n            df_tips()[\"time\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # placeholder for joined dataframe\n    @reactive.calc\n    def df_tips():\n        # fmt: off\n        data = {\n            'total_bill': [\n                16.99, 10.34, 21.01, 23.68, 24.59,\n                25.29, 8.77, 26.88, 15.04, 14.78\n            ],\n            'tip': [\n                1.01, 1.66, 3.50, 3.31, 3.61,\n                4.71, 2.00, 3.12, 3.52, 3.00\n            ],\n            'sex': [\n                'Female', 'Male', 'Male', 'Male', 'Female',\n                'Male', 'Male', 'Male', 'Male', 'Female'\n            ],\n            'smoker': [\n                'No', 'No', 'No', 'No', 'Yes',\n                'No', 'No', 'Yes', 'No', 'Yes'\n            ],\n            'day': [\n                'Sun', 'Fri', 'Sun', 'Thu', 'Sun',\n                'Sun', 'Sat', 'Sat', 'Sat', 'Sat'\n            ],\n            'time': [\n                'Dinner', 'Dinner', 'Lunch', 'Dinner', 'Lunch',\n                'Dinner', 'Lunch', 'Dinner', 'Lunch', 'Dinner'\n            ],\n            'size': [2, 3, 3, 2, 4, 4, 2, 4, 2, 2]\n        }\n        # fmt: on\n\n        df = pd.DataFrame(data)\n        return df\n\n\napp = App(app_ui, server)\n\n\nSince we made the mistake of mixing and converting data types, we can use Python type hints to make it clear to others what is happening with the data types, and also as a cue to ourself if we end up using types that we do not expect.\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 650\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\napp_ui = ui.page_fixed(\n    ui.output_ui(\"table_day_filter\"),\n    ui.output_ui(\"table_time_filter\"),\n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n\n    @reactive.calc\n    def filter_idx() -&gt; pd.Index: #&lt;&lt;\n        df = df_tips()\n        idx = df.index\n\n        filters = [\"filter_day\", \"filter_time\"]\n        cols = [\"day\", \"time\"]\n\n        for fltr, col in zip(filters, cols):\n            if input[fltr]():\n                current_idx = df.loc[df[col].isin(input[fltr]())].index\n                idx = idx.intersection(current_idx)\n\n        return idx\n\n\n    # filtered dataframe from filters\n    @reactive.calc\n    def data_filtered() -&gt; pd.DataFrame: #&lt;&lt;\n        df = df_tips().loc[filter_idx()]\n        return df\n\n    # dataframe to view in app\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\n    # table day filter\n    @render.ui\n    def table_day_filter():\n        return ui.input_selectize(\n            \"filter_day\",\n            \"table day filter:\",\n            df_tips()[\"day\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # table time filter\n    @render.ui\n    def table_time_filter():\n        return ui.input_selectize(\n            \"filter_time\",\n            \"table time filter:\",\n            df_tips()[\"time\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # placeholder for joined dataframe\n    @reactive.calc\n    def df_tips():\n        # fmt: off\n        data = {\n            'total_bill': [\n                16.99, 10.34, 21.01, 23.68, 24.59,\n                25.29, 8.77, 26.88, 15.04, 14.78\n            ],\n            'tip': [\n                1.01, 1.66, 3.50, 3.31, 3.61,\n                4.71, 2.00, 3.12, 3.52, 3.00\n            ],\n            'sex': [\n                'Female', 'Male', 'Male', 'Male', 'Female',\n                'Male', 'Male', 'Male', 'Male', 'Female'\n            ],\n            'smoker': [\n                'No', 'No', 'No', 'No', 'Yes',\n                'No', 'No', 'Yes', 'No', 'Yes'\n            ],\n            'day': [\n                'Sun', 'Fri', 'Sun', 'Thu', 'Sun',\n                'Sun', 'Sat', 'Sat', 'Sat', 'Sat'\n            ],\n            'time': [\n                'Dinner', 'Dinner', 'Lunch', 'Dinner', 'Lunch',\n                'Dinner', 'Lunch', 'Dinner', 'Lunch', 'Dinner'\n            ],\n            'size': [2, 3, 3, 2, 4, 4, 2, 4, 2, 2]\n        }\n        # fmt: on\n\n        df = pd.DataFrame(data)\n        return df\n\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "posts/010-initial/index.html#final-initial-prototype",
    "href": "posts/010-initial/index.html#final-initial-prototype",
    "title": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application",
    "section": "Final Initial Prototype",
    "text": "Final Initial Prototype\nOur final application is fairly simple, a couple of filter components that reactively subset a dataframe that gets shown in the app.\nInternally, we’ve made a few key implementation decisions:\n\nTrack the row index label\nCompute and use a pandas.Index for the dataframe filter\n\nWe’ve also left a few placeholders to help scale the application:\n\nStore the data as a @reactive.calc, df_tips()\nLoop through all the filters to track the .intersection()\n\nAnd saw how to watch out for certain code patters to avoid:\n\nChanging data types of a variable in a function\nChanging the expected return type of a variable\n\nIn the next part, we’ll add more filter components to the app and see what complexities arise when we work with more data types."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learning Shiny",
    "section": "",
    "text": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application\n\n\nInitial Prototype: Handling Filter Values\n\n\n\n\n\n\n\n\nDaniel Chen\n\n\n\n\n\n\nNo matching items"
  }
]