[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/030-010-what_i_learned/index.html",
    "href": "posts/030-010-what_i_learned/index.html",
    "title": "Tips for Implementing Custom Features in Shiny",
    "section": "",
    "text": "Earlier this year, I wanted to create a data explorer app using Shiny for Python. It is the kind of application you see a lot on government data portals. You have a few visualizations about the data, look at data raw data set, apply filters to subset the data set, and be able to download the final data set so you can use it locally.\nShiny did not have the type of filtering behavior I wanted, so I needed to build my own. I got the opportunity to work with Joe Cheng at Posit to learn about building software and shiny modules. Here’s a few tips I learned through the process if you want to build your own custom features into Shiny."
  },
  {
    "objectID": "posts/030-010-what_i_learned/index.html#background",
    "href": "posts/030-010-what_i_learned/index.html#background",
    "title": "Tips for Implementing Custom Features in Shiny",
    "section": "Background",
    "text": "Background\nOne part that always bothered me when using components to interactively filter a data set was that, nothing prompted me about which filter options were valid as I was interacting with the application. I would frequently end up choosing a combination of filters that would return an empty dataframe. Clicking around and not knowing you would end up with an empty dataframe was a bit jarring. A big chunk of my interface would just disappear.\nThe current set of shiny filters and the way most shiny apps are written have all the filtering components and each other to filter the data. This is why it will return an empty dataframe.\nWhat I wanted were filters that were aware of what the other filters were doing, and update their own values that adapts to the other filters. There was no way to do this in Shiny for Python out-of-the box, so I had to go and implement the feature on my own, and hopefully be able to share it with everyone else."
  },
  {
    "objectID": "posts/030-010-what_i_learned/index.html#tip-1-keep-variable-types-consistent",
    "href": "posts/030-010-what_i_learned/index.html#tip-1-keep-variable-types-consistent",
    "title": "Tips for Implementing Custom Features in Shiny",
    "section": "Tip 1: Keep Variable Types Consistent",
    "text": "Tip 1: Keep Variable Types Consistent\n\nAs a data scientist, we typically write code in some kind of pipeline. So, we end up making sequential modifications to a variable. My advice, do not reuse the same variable names, especially if you are going to be changing the variable’s type throughout the code. It adds to cognitive load when trying to understand the implementation and also makes it a bit harder to reason about during maintenance.\n\nExample\n\n\nHere’s an actual example of the code I wrote that illustrates this point. I want to take the intersection of data frame index values so I can get a final index of values I can use to subset my dataframe that represents the choices the user selected in my filter components.\nThe function does these steps\n\nGet the dataframe\nGet the index of the dataframe\nConvert the index to a set\nPerform the set intersection\nReturn a list of the values\n\n\n@reactive.calc\ndef filter_idx():\n    df = df_tips() \n    idx = set(df.index) \n\n    if input.filter_day():\n        current_idx = df.loc[df[\"day\"].isin(input.filter_day())].index\n        idx = idx.intersection(set(current_idx)) \n\n    if input.filter_time():\n        current_idx = df.loc[df[\"time\"].isin(input.filter_time())].index\n        idx = idx.intersection(set(current_idx)) \n\n    return list(idx) # list because .loc[] would return TypeError\n\n\nThe idx variable undergoes 3 type changes, index, set, and list!\n\nIf you just plan to use this function (technically a @reactive.calc), you would only care that it returns something that you can use to subset a dataframe with. That’s the benefit of abstraction, but as someone who will maintain the code base, and in my case pair-programming, it makes the implementation extremely hard to follow.\nTurns out pandas Index objects, have an .intersection() method. So, no reason to convert to a set, and we can implement everything we need with the same data type.\n\n@reactive.calc\n@reactive.calc\ndef filter_idx():\n    df = df_tips() \n    idx = df.index \n\n    if input.filter_day():\n        current_idx = df.loc[df[\"day\"].isin(input.filter_day())].index\n        idx = idx.intersection(current_idx) \n\n    if input.filter_time():\n        current_idx = df.loc[df[\"time\"].isin(input.filter_time())].index\n        idx = idx.intersection(current_idx) \n\n    return idx \n\nMuch better! No more getting values of one type, and doing inline type conversions to make a calculation and returning an entirely different type. This makes the implementation much easier to reason with, and if you’re skimming the code to track a bug, you won’t miss the set() and list() calls."
  },
  {
    "objectID": "posts/030-010-what_i_learned/index.html#tip-2-use-python-type-hints",
    "href": "posts/030-010-what_i_learned/index.html#tip-2-use-python-type-hints",
    "title": "Tips for Implementing Custom Features in Shiny",
    "section": "Tip 2: Use Python Type Hints",
    "text": "Tip 2: Use Python Type Hints\nPython Type hints are a way where you can quickly see what datatype you are working with. Especially when your code base is a bit larger and you need to know what the inputs and outputs of a function are.\nYou won’t need to rely on duck typing and “hope for the best”. Your intensions are clear. The problem I encountered from the previous issue, can be mitigated by writing the code better, but adding type hints can help with larger code bases when you are working with different types.\nPython is a dynamically typed language, variables do not need explicit type declarations. This is where Python’s “duck typing” comes from, and is what makes python flexible as a scripting language, but can make it more difficult to understand and maintain in larger projects.\nPython type hints were introduced in PEP 484 and implemented in Python 3.5. They help address duck typing ambiguity with type annotations. Type hints specify the expected types for variables, function arguments, and return values. Type hints don’t enforce types at runtime (you can even put in incorrect types). They can serve as documentation, improve code readability, and enable tools to catch type-related errors.\n\nPyright\nPyright and Mypy are two of the more popular static type checkers for Python. The Shiny team uses Pyright in strict mode in their code base. Sometimes you need to go out of your way to make the type checker happy. But, the benefit is you get complete type safety and will see warnings as you work. This makes your code much easier to maintain, bring on new people, and reason with as your are working on different parts of the codebase.\n\nExamples\nHere are 2 different examples of basic type hints in Python\n\nWarns You About Variable Redeclaration\nIf you end up completely redefining the type of a variable with the same name (not exactly the same situation from Tip 1), you will get a reportRedeclaration message from the type checker.\n\nfrom __future__ import annotations\n\nimport pandas as pd\n\nidx_int: pd.Index[Any] = pd.Index([1, 2, 3]) # reportRedeclaration here\nidx_int: pd.Index[int] = pd.Index([1, 2, 3])\n\nYou may need the from __future__ import annotations at the top of your python file. This allows type hints to be stored as strings rather than immediately being evaluated. Without it, you may get a TypeError, in this specific example, you would can get a TypeError: type 'Index' is not subscriptable message.\n\n\nTurn Off Specific Warnings\nSometimes things are out of your control, and you will manually need to turn off a warning. One example comes from pandas, where I used their functions to determine the dtype of a Series.\nfrom pandas.api.types import is_numeric_dtype, is_string_dtype\nPyright reports a reportUnknownVariableType error, and there is not much I can do to fix this error without making a change to the main pandas library, or pandas-stubs.\nPyright 1.1.229+ supports suppressing individual diagnostics\n# pyright: ignore [reportUnknownVariableType]\n\n\n\n\nCast\nThe cast() function is used when you know (or assume) that a variable is of a specific type, even if Python or a static type checker might not infer it directly. You do need to be careful when using cast(), since you are intensionally making an assumption about the variable type, and if you get it wrong, it would be difficult to track down the bug.\n\nExample\nOne example that was used in the adaptive_filter codebase was telling Pyright the type of data stored in the dataframe index. We used a function to return the index of a dataframe to make sure the type checker understands the data type stored.\n\nfrom typing import Any, cast\n\ndef return_index(df: pd.DataFrame) -&gt; \"pd.Index[Any]\":\n    return cast(\"pd.Index[Any]\", df.index)\n\nNow anywhere we would normally call df.index we would now call return_index(df)\n\n\n\nTypeVar and Generics\nTypeVar and Generics are tools in the python typing system that allows you to create more flexible (i.e., “generic”) type hints where you can put in a placeholder for a types and delay specifying the actual type later on, while still maintaining type safety.\nIf you are familiar with object oriented programming (OOP), inheriting objects from a common base class, or abstract base class (abc), then TypeVar and Generics are how you will add type hints to your base class.\n\nExample\nIn our adaptive filter module, we had an abc for a BaseFilter class, One of the methods in the abc returns needs to return values from a filter component, but depending on the data stored in the filter, it may return values as a str or int.\nfrom abc import ABC\nfrom typing import TypeVar, Generic, Iterable\n\nT = TypeVar(\"T\")\n\n\nclass BaseFilter(ABC, Generic[T]):\n    ...\n\n    def _get_input_value(self) -&gt; Iterable[T] | None:\n        ...\nWhen we go implement each object that inherits from BaseFilter, we can pass in the actual type that T was used as a placeholder.\n# class that can deal with categorical variables stored as a string\nclass FilterCatStringSelect(BaseFilter[str]):\n    ..."
  },
  {
    "objectID": "posts/030-010-what_i_learned/index.html#tip-3-know-when-you-should-use-shiny-modules",
    "href": "posts/030-010-what_i_learned/index.html#tip-3-know-when-you-should-use-shiny-modules",
    "title": "Tips for Implementing Custom Features in Shiny",
    "section": "Tip 3: Know When You Should Use Shiny Modules",
    "text": "Tip 3: Know When You Should Use Shiny Modules\nShiny modules are used to follow the DRY (Don’t Repeat Yourself) principle. The same concept of creating functions so you can abstract away and reuse computations, is a similar concept of shiny modules. The term “module” in Python typically refers to a .py file that contains python functions that get imported into a file. While “shiny modules” are typically .py files that get imported into the app, the term “shiny module” is not synonymous with a regular “module”. “Shiny modules” are specifically used in a shiny for Python application to encapsulate reactive components in a namespace to avoid namespace clashing of the component id because each component in shiny must have a unique id.\nWriting functions isn’t the only way you can reduce repeated code. for loops are another common way to write code to reuse a common code base for repeated actions. So how do you know when you need to refactor your code into shiny modules? What “code smells” should you look out for?\n\nTracking List(s) of Component Values\nIf you find yourself in any of the following situations, you may want to think about refactoring your code into a shiny module.\n\nCalling the same component creating function multiple times.\nCreating a list of id values and iterating over and calling a function that makes a component.\nCreating at least 2 lists that track the id and some other input for the component.\n\nFor example a separate list for the id or label, but can also include things like a column name of a dataframe.\n\nIterating across lists(s) to ensure inputs are captured together\n\nEspecially if you find your self using the zip() function\n\n\n\nExample\nIn the adaptive filter module, the initial implementation tracked 3 things: id, column name, and type of variable stored in the column.\n\nfilters = [\"filter_size\", \"filter_id\", \"filter_total_bill\"]\ncols = [\"size\", \"id\", \"total_bill\"]\ncol_types = [\"cat\", \"cat\", \"sliders\"]\n\nfor fltr, col, col_type in zip(filters, cols, col_types):\n    ...\n\nAll 3 bits of information needed to be tracked together.\n\nfilters: get the user inputs from the ui.\ncols: tied to the filters variable, and used to extract the corresponding column from the data.\ncol_type: determine how the data needed to be filtered. For example, selectize components always return values as a list of strings (List[str]), and needed to be converted to a numeric type to filter the data.\n\nFrom a maintenance and end user perspective, knowing the column name should be enough to figure out the rest of the parts. As long as your provide a way for the end user to override any default, the code as written forces them to manually track a lot of unnecessary information for their own application.\n\n\n\nComplex and Interweaved Behaviors\nThe previous “code smells” are listed in the Shiny for Python modules documentation, but there are other ways you may want to consider whether or not you need modules.\n\nDynamically creating component ids without fear of clashing with the main application.\nComplex/complicated operations that are specific to a function and requires multiple other @reactive intermediate steps.\nCoupling: where adding another feature into the application requires changing the codebase in many parts of the application in both the server() and ui.\n\nWhen you create a module, you specifically create a namespace for all the components inside. Whatever id names and calculations you need are all in their own namespace.\n\nExample\nUsing the same code example from above, we are manually tracking 3 parts for each component.\n\nfilters = [\"filter_size\", \"filter_id\", \"filter_total_bill\"]\ncols = [\"size\", \"id\", \"total_bill\"]\ncol_types = [\"cat\", \"cat\", \"sliders\"]\n\nIf we are giving just the column name, cols, we can automatically create the id by prepending the filter_ string. We can run into a risk that if this component was just a function, it will clash with an existing id by the end user, e.g., what if they already have a filter_size component id for something else? If you think the answer is to add more underscores _ to the id name, and create something like _filter__size, then you really need to encapsulate the function into a module.\nBy default, we don’t really need the end user to provide anything, just the dataframe is enough to get the cols value, from there we can generate the filters list, and we can write out own function that calculates a col_types. We talk more about user overrides in Tip 5, for now let’s assume we only have 3 columns in our entire data set. All 3 of those calculations can be done in separate @reactive calls. A module will be able to abstract away all these calculations outside the main app.py, and make the main application easier to maintain.\nFinally, if we wanted to add another adaptive filter component into the application, we need to track the information in at least 3 places:\n# in the server function of the application\ncurrent_ids = df.loc[df[col].isin(filter_value)].index\n\n# in one of the helper functions\nif is_string_dtype(col):\n    return \"cat_str\"\n\n# in the server and/or ui of the application\nui.output_ui(\"table_size_filter\"),\n\n@render.ui\ndef table_id_filter():\n    return ui.input_selectize(\n        \"filter_id\",\n        \"id filter:\",\n        sorted(df_tips()[\"id\"].unique().tolist()),\n        multiple=True,\n        remove_button=True,\n        options={\"plugins\": [\"clear_button\"]},\n    )\nJust needing to create a new component, or new component type requires the user to change the code many locations in the application. Forgetting to change any one of the locations is a common mistake, and can be easily forgotten. As the application grows, the places where the codebase needs to be updated to incorporate new features will be farther apart, i.e., more lines of code between needed changes. Creating a module can keep the coupling of code closer together, so making changes or extensions is easier."
  },
  {
    "objectID": "posts/030-010-what_i_learned/index.html#tip-4-make-your-shiny-app-testable",
    "href": "posts/030-010-what_i_learned/index.html#tip-4-make-your-shiny-app-testable",
    "title": "Tips for Implementing Custom Features in Shiny",
    "section": "Tip 4: Make Your Shiny App Testable",
    "text": "Tip 4: Make Your Shiny App Testable\nTesting is always a good idea. When working with shiny you want to split up functions that require shiny end-to-end and behavior testing, with your main logic.\nNot everything needs to be in the server function, and not everything needs to be inside a reactive. You can still call regular python functions, so when possible, write regular functions and call them in a reactive. If you have written unit tests before or used the assert statement, then you can still write tests for your Shiny application.\n\nTesting Functions with pytest\nIf you are able to refactor your code into individual non-reactive functions, you can leverage the larger unit testing infrastructure python provides, e.g., pytest This is a great general shiny tip, where you can and should be able to create helper functions completely outside of any @reactive context, and then call the function inside a @reactive.\n\nExample\nHere is a helper function that was used in our adaptive filters module, It takes in a list of pandas Index objects, and finds the .intersection() across all the objects. This calculation is used many times throughout the application. It also makes a few data checks beforehand (expressed by the ... in the code below).\n\ndef index_intersection_all(\n    to_intersect: List[\"pd.Index[Any] | None\"],\n    default: \"pd.Index[Any]\",\n) -&gt; \"pd.Index[Any]\":\n\n    ...\n\n    intersection = intersect[0]\n    for index in intersect:\n        intersection = intersection.intersection(index)\n\n    return intersection\n\nWe can test this function like a regular Python function.\n\nimport pandas as pd\n\nidx1 = pd.Index([1, 2, 3, 4, 5])\nidx2 = pd.Index([2, 3, 4, 5, 6])\nidx3 = pd.Index([3, 4, 5, 6, 7])\ndefault = pd.Index([1, 2, 3, 4, 5, 6, 7])\n\ndef test_index_intersection_all():\n    to_intersect = [idx1, idx2, idx3]\n    expected = pd.Index([3, 4, 5])\n    calculated = index_intersection_all(\n        to_intersect,\n        default=default,\n    )\n    assert (calculated == expected).all()\n    assert calculated.equals(expected)\n\nYou can then leverage all the benefits and tools from pytest in testing your shiny application and/or shiny module, including test fixtures.\n\n\n\nPlaywright\nTesting the reactivity and end-to-end behavior in Shiny for Python is limited to Playwright. The Shiny for Python documentation has an article on End-to-end testing for Shiny. You can run your end-to-test testing with pytest and playwright with\npip install pytest pytest-playwright\nYou are a bit limited to the capabilities of Playwright, but Shiny does have a few wrappers for playwright that makes it easier for you to test your application.\nFirst, Shiny provides you a controller object. This provides you a more convenient way of finding input or output components by the id that was used in the application.\nfrom shiny.playwright import controller\nFrom there, you can use the Shiny Testing API docs to find the corresponding component in your application that you want to test. For example, this is the documentation for the InputSelectize playwright controller.\nWe then create our test app and test function. This will run the shiny application in a single browser tab, and then go to the app URL.\nfrom shiny.run import ShinyAppProc\nfrom playwright.sync_api import Page\nfrom shiny.pytest import create_app_fixture\n\napp = create_app_fixture(\"app.py\")\n\ndef test_basic_app(page: Page, app: ShinyAppProc):\n    page.goto(app.url)\n    ...\nFrom there we can use various .set(), .expect_*(), methods from the controller components to modify the application and test the results.\nThe tests will run through pytest.\npytest .\nYou do have the option to set different browsers and also headlessly (default) or headed (by passing --headed). Changing browsers and the “headedness” can help see if your issue is specific to the application or with the browser.\npytest . --browser chromium --headed # chromium also headed\npytest . --browser firefox # firefox\npytest . --browser webkit # webkit/safari\n\nExample\nHere’s an example of a test we used in a simple adaptive filter application.\nfrom shiny.playwright import controller\nfrom shiny.run import ShinyAppProc\nfrom playwright.sync_api import Page\nfrom shiny.pytest import create_app_fixture\n\napp = create_app_fixture(\"app.py\")\n\n\ndef test_basic_app(page: Page, app: ShinyAppProc):\n    page.goto(app.url)\n\n    selectize_day = controller.InputSelectize(page, \"adaptive-filter_day\")\n    selectize_day.set(\"Fri\")\n    selectize_day.expect_selected([\"Fri\"])\n\n    selectize_time = controller.InputSelectize(page, \"adaptive-filter_time\")\n    selectize_time.expect_choices([\"Dinner\"])\nSince the adaptive filters are created within a shiny module, we have to be mindful of the id given for the module’s namespace. The actual component will be the given id followed by a dash, -, then whatever id was used for the component inside the shiny module.\nFor example, if we called the module with the adaptive id,\nfilter_return = adaptive_filter_module.filter_server(\"adaptive\", df=tips)\nthe component id of the application for the day column filter would be adaptive-filter_day because inside the module, our filter names use a filter_colname format.\nFrom there, we can test clicking on a day of the week using an adaptive filter, and checking to see if another filter’s values have changed to the selection."
  },
  {
    "objectID": "posts/030-010-what_i_learned/index.html#tip-5-think-of-the-developer-experience",
    "href": "posts/030-010-what_i_learned/index.html#tip-5-think-of-the-developer-experience",
    "title": "Tips for Implementing Custom Features in Shiny",
    "section": "Tip 5: Think of the Developer Experience",
    "text": "Tip 5: Think of the Developer Experience\n\nPeople will only use your tools if you make it easy for them to use. This is a bit of an art, and every situation is going to be different.\nIf this is code just for yourself, and only you will maintain a codebase in the future, then the user interface does not need to be as seamless. If you are going to put this codebase into the hands of other people, and you are trying to get people to adopt your tool, then you do not want to put any more hurdles in their way. You will also need to think about the skill of the average person who may use your tool.\nShiny is a tool for data scientists, and because of data science’s popularity in the last decade, the training for a data scientist is not from software engineering and computer science.\nBut when a tradeoff between convenience for the user, the future developer who will extend the library, yourself in the future, or the object oriented dogma. Sometimes it might be okay to sacrifice the dogma to make everything else convenient.\n\n\nExample\nThe filters will try its best to use simple heuristics to automatically return the correct filter type based on the contents of the column.\nWe ended up writing the code, so the user can provide customizations in one of 3 ways:\n\nRemove a component with None\nSpecify a new label with just a string\nOverride the default calculated component type by passing the object\nProvide a label parameter to a custom component type to rename the label\n\nHere’s an example of how the user can customize the components\noverride = {\n    \"total_bill\": None,\n    \"day\": \"DAY!\",\n    \"time\": shiny_adaptive_filter.FilterCatStringSelect(),\n    \"size\": shiny_adaptive_filter.FilterCatNumericCheckbox(label=\"Party Size\"),\n}\nAll of the filters are documented in the module for the app author to look up, and provides an easy interface for them to use: the dictionary keys are the columns of the data set, and the values are any manual overrides the developer wants in their application.\n# in the ui\nshiny_adaptive_filter.filter_ui(\"adaptive\")\n...\n\n# in the server\nadaptive_filters = shiny_adaptive_filter.filter_server(\n    \"adaptive\", df=data, override=override\n)\n\n# a reactive value that can be used anywhere else in the app\nadaptive_filters_idx = adaptive_filters[\"filter_idx\"]\nThe implementation we used in adaptive filters uses an old C trick of having a finish_init() method that is run after the developer passes in the inputs for the constructor.\n\nclass BaseFilter(ABC, Generic[T]):\n    def __init__(self, *, label: str | None = None):\n        ...\n\n    def finish_init(\n        self,\n        data: Callable[[], pd.DataFrame] | pd.DataFrame,\n        id: str,\n        column_name: str,\n        *,\n        session: Session | None = None,\n    ):\n        ...\n\n        return self\nThis is so the user only needs to pass in the type of filter they want to override, or the component label that will be displayed in the application. This decision was made so it balances user convenience and developer convenience, but sacrifices on one of the dogmas of object oriented programming, where a valid object gets created, but still cannot be used until another method gets called. Anytime the filter constructor gets called with the user inputs, we must call the .finish_init() method to have a use able filter component object.\nshiny_adaptive_filter.FilterCatStringCheckbox(label=label)\\\n    .finish_init(df, id, col_str, session=session)\nThis tradeoff was made to avoid having the user pass in a partial (aka currying) or lambdas. Contrast the original override dictionary with either of the ones below, and you can see how sacrificing the object oriented dogma may be worth it to make the tool easier for users.\nfrom functools import partial\n\noverride = {\n    # using a partial\n    \"time\": partial(shiny_adaptive_filter.FilterCatStringCheckbox, label=\"Time of Day\"),\n\n    # using a lambda\n    \"size\": lambda data, id, colname, session: shiny_adaptive_filter.FilterCatNumericCheckbox(data, id, colname, label=\"Time of Day\", session=session),\n}"
  },
  {
    "objectID": "posts/030-010-what_i_learned/index.html#conclusion",
    "href": "posts/030-010-what_i_learned/index.html#conclusion",
    "title": "Tips for Implementing Custom Features in Shiny",
    "section": "Conclusion",
    "text": "Conclusion\nI like to remind my student students that just because the code works without error, doesn’t mean it’s correct, and just because it’s correct, doesn’t mean you can’t improve it.\nI wanted a shiny app to have filter behaviors that did not exist and set off creating a custom implementation to be able to share with others. This lead me to create custom filtering component behaviors, refactoring them into shiny modules, and creating a python package to share with others. Along the way I got help from Joe Cheng, CTO at Posit, PBC and one of the main authors of Shiny, who taught me how to take my original proof of concept code, and make it respectable from a software engineering point of view. Can the codebase be improved? Absolutely. But I hope the tips in this post can help level up your software engineering skills as a data scientist.\nHere’s a minimal example of the adaptive filters at work. Set the day checkbox to Fri and see how the other filters “adapt” to the results. If you want to give it a try yourself, you can install the filters from PyPI.\npip install shiny_adaptive_filter\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 700\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\nimport shiny_adaptive_filter as af\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        af.filter_ui(\"adaptive\"),\n    ),\n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n    @reactive.calc\n    def tips_reactive():\n        return tips\n\n    @reactive.calc\n    def data_filtered():\n        df = tips_reactive().loc[filter_idx()]\n        return df\n\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\n    override = {\n    \"total_bill\": None,\n    \"tip\": None,\n    }\n\n    filter_return = af.filter_server(\n        \"adaptive\",\n        df=tips_reactive,\n        override=override,\n    )\n    filter_idx = filter_return[\"filter_idx\"]\n\ndata = {\n    'total_bill': [16.99, 10.34, 21.01, 23.68, 24.59],\n    'tip': [1.01, 1.66, 3.50, 3.31, 3.61],\n    'sex': ['Female', 'Male', 'Male', 'Male', 'Female'],\n    'smoker': ['No', 'No', 'No', 'No', 'Yes'],\n    'day': ['Sun', 'Sun', 'Sun', 'Fri', 'Sun'],\n    'time': ['Lunch', 'Dinner', 'Dinner', 'Dinner', 'Dinner'],\n    'size': [2, 3, 3, 2, 4]\n}\n\ntips = pd.DataFrame(data)\n\napp = App(app_ui, server)\n\n\n## file: requirements.txt\nshiny_adaptive_filter"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learning Shiny",
    "section": "",
    "text": "Introducing Adaptive Filters\n\n\nA betty way to filter your data in shiny\n\n\n\n\n\n\n\n\nDaniel Chen\n\n\n\n\n\n\n\n\n\n\n\n\nTips for Implementing Custom Features in Shiny\n\n\nCreating and Testing Your Shiny Modules\n\n\n\n\n\n\n\n\nDaniel Chen\n\n\n\n\n\n\n\n\n\n\n\n\nPart I: Learning Software Engineering for Data Scientists - Building a Shiny Application\n\n\nInitial Prototype: Handling Filter Values\n\n\n\n\n\n\n\n\nDaniel Chen\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/020-010-adaptive_filters/index.html",
    "href": "posts/020-010-adaptive_filters/index.html",
    "title": "Introducing Adaptive Filters",
    "section": "",
    "text": "One of the main limitations when trying to use Shiny components to filter a dataframe is the filters mainly work in an and operator on the data. This means that when you are trying to use interactively explore your data, you will inevitably end up selecting a combination of filter values that will return an empty dataframe.\nWe have created a new set of shiny selectize and checkbox filters to help you with these kinds of interactive data filtering tasks.\nTake a look at an example application using the new filters."
  },
  {
    "objectID": "posts/020-010-adaptive_filters/index.html#the-problem",
    "href": "posts/020-010-adaptive_filters/index.html#the-problem",
    "title": "Introducing Adaptive Filters",
    "section": "The Problem",
    "text": "The Problem\n\nImagine this small tips dataset\n\n\nCode\nimport pandas as pd\n\ndata = {\n    'total_bill': [16.99, 10.34, 21.01, 23.68, 24.59],\n    'tip': [1.01, 1.66, 3.50, 3.31, 3.61],\n    'sex': ['Female', 'Male', 'Male', 'Male', 'Female'],\n    'smoker': ['No', 'No', 'No', 'No', 'Yes'],\n    'day': ['Sun', 'Sun', 'Sun', 'Fri', 'Sun'],\n    'time': ['Lunch', 'Dinner', 'Dinner', 'Dinner', 'Dinner'],\n    'size': [2, 3, 3, 2, 4]\n}\n\ntips = pd.DataFrame(data)\ntips\n\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n0\n16.99\n1.01\nFemale\nNo\nSun\nLunch\n2\n\n\n1\n10.34\n1.66\nMale\nNo\nSun\nDinner\n3\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nDinner\n3\n\n\n3\n23.68\n3.31\nMale\nNo\nFri\nDinner\n2\n\n\n4\n24.59\n3.61\nFemale\nYes\nSun\nDinner\n4\n\n\n\n\n\n\n\nIn shiny, you will typically create separate input components for each column you want the user to interact with and filter down the data. If we made filters for all the categorical variables and wanted to filter the day variable down to Fri.\n\n\nCode\ntips.loc[tips[\"day\"] == \"Fri\"]\n\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n3\n23.68\n3.31\nMale\nNo\nFri\nDinner\n2\n\n\n\n\n\n\n\nTraditionally, your filter components will still have options for the entire dataframe, it does not react to the filters you already selected. In a traditional shiny application, you will still see Lunch in the time filter. This means the user can still select Fri and subsequently, Lunch and be left with an empty dataframe result.\n\n\nCode\ntips.loc[(tips[\"day\"] == \"Fri\") & (tips[\"time\"] == \"Lunch\")]\n\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n\n\n\n\n\n\nThis empty dataframe result may not be what you want the end user to see.\nHere’s an example of the behaviour in a simple app.\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 700\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\ndata = {\n    'total_bill': [16.99, 10.34, 21.01, 23.68, 24.59],\n    'tip': [1.01, 1.66, 3.50, 3.31, 3.61],\n    'sex': ['Female', 'Male', 'Male', 'Male', 'Female'],\n    'smoker': ['No', 'No', 'No', 'No', 'Yes'],\n    'day': ['Sun', 'Sun', 'Sun', 'Fri', 'Sun'],\n    'time': ['Lunch', 'Dinner', 'Dinner', 'Dinner', 'Dinner'],\n    'size': [2, 3, 3, 2, 4]\n}\n\ntips = pd.DataFrame(data)\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_selectize(\n                \"filter_day\",\n                \"table day filter:\",\n                tips[\"day\"].unique().tolist(),\n                multiple=True,\n        ),\n        ui.input_selectize(\n                \"filter_time\",\n                \"table time filter:\",\n                tips[\"time\"].unique().tolist(),\n                multiple=True,\n        ),\n    ),\n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n    @reactive.calc\n    def data_filtered():\n        df = tips\n        if input.filter_day():\n            df = df.loc[df[\"day\"].isin(input.filter_day())]\n        if input.filter_time():\n            df = df.loc[df[\"time\"].isin(input.filter_time())]\n        return df\n\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "posts/020-010-adaptive_filters/index.html#adaptive-filters",
    "href": "posts/020-010-adaptive_filters/index.html#adaptive-filters",
    "title": "Introducing Adaptive Filters",
    "section": "Adaptive Filters",
    "text": "Adaptive Filters\nThe new adaptive filters change updates the values of the inputs so it “adapts” to all the filtering that is done to your data, while keeping the results for values you have already selected. We think this provides a better user experience when exploring data interactively.\n\nInstalling and Usage\nYou can give the new components a try.\npip install adaptive_filter # TODO: check final name\nTo use the components you will need to import the shiny module\nfrom shiny_adaptive_filter import adaptive_filter_module\nYou then pass the module id and data into the server module, and then place the UI where you want with the ui module.\n# in the UI\nadaptive_filter_module.filter_ui(\"adaptive\")\n\n# in the server function\nadaptive_filters = adaptive_filter_module.filter_server(\n        \"adaptive\",\n        df=tips_original,\n    )\nThe module returns an index of values that the application author can use to filter their data in a @reactive.calc\nadaptive_filters_idx = adaptive_filters[\"filter_idx\"]\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 700\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\nfrom pyshiny_adaptive_filter import adaptive_filter_module\n\ndata = {\n    'total_bill': [16.99, 10.34, 21.01, 23.68, 24.59],\n    'tip': [1.01, 1.66, 3.50, 3.31, 3.61],\n    'sex': ['Female', 'Male', 'Male', 'Male', 'Female'],\n    'smoker': ['No', 'No', 'No', 'No', 'Yes'],\n    'day': ['Sun', 'Sun', 'Sun', 'Fri', 'Sun'],\n    'time': ['Lunch', 'Dinner', 'Dinner', 'Dinner', 'Dinner'],\n    'size': [2, 3, 3, 2, 4]\n}\n\ntips = pd.DataFrame(data)\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        adaptive_filter_module.filter_ui(\"adaptive\"), \n    ),\n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n    @reactive.calc \n    def tips_reactive(): \n        return tips \n\n    @reactive.calc\n    def data_filtered():\n        df = tips_reactive().loc[filter_idx()] \n        return df\n\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\n    filter_return = adaptive_filter_module.filter_server( \n        \"adaptive\", \n        df=tips_reactive, \n    ) \n    filter_idx = filter_return[\"filter_idx\"] \n\napp = App(app_ui, server)\n\n\n## file: requirements.txt\nshiny_adaptive_filter\n\n\n\nOverrides\nBy default, the module will try to create an adaptive filter for all the columns in your data. It tries to make sensible defaults for the kind of component you want. However, you can change (i.e., override) any of the default behaviours.\nThere are 3 (3) kinds of overrides you can provide.\n\nChange the filter type\nDisable a filter\nChange the filter label\n\nWe do this by creating a python dictionary where keys are the column names of the incoming dataframe that we want to target.\nWe can turn “off” a filter by passing in None as the value. To change the filter type, we can pass in the filter constructor. If you want to change the filter label, pass in a string of the new label.\noverride = {\n    \"total_bill\": None, # disable the total_bill column\n\n}"
  },
  {
    "objectID": "posts/010-initial/index.html",
    "href": "posts/010-initial/index.html",
    "title": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application",
    "section": "",
    "text": "We want to create a data portal application where users can pick data sets to be joined together and filters to filter the data. The final application will have the following features:\nThis is a series of building a shiny application that serves as a reference for a larger and more complicated application. It also goes through implementing a solution, improving it, and refactoring it as we go. It comes from a series of 1:1 meeting’s with Joe Cheng on the Shiny team\nThink of this series as a “data scientist’s guide to thinking like a software engineer”."
  },
  {
    "objectID": "posts/010-initial/index.html#base-application",
    "href": "posts/010-initial/index.html#base-application",
    "title": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application",
    "section": "Base Application",
    "text": "Base Application\nWe’ll build on a small example dataframe using a sample of a generated tips data set. Some of the more complex decisions and features of the application we can put in place holder elements for\n\nThe data will come from a @reactive.calc and be a placeholder for a final joined dataframe\nAll the UI elements will eventually be created by a larger @render.ui call, so the UI elements will all be created in the server() function\n\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 500\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\napp_ui = ui.page_fixed(\n    ui.output_ui(\"table_day_filter\"), \n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n\n    # filtered dataframe from filters \n    @reactive.calc \n    def data_filtered(): \n        df = df_tips() \n\n        if input.filter_day(): \n            df = df.loc[df[\"day\"].isin(input.filter_day())] \n\n        return df \n\n    # dataframe to view in app\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\n    # table day filter \n    @render.ui \n    def table_day_filter(): \n        return ui.input_selectize( \n            \"filter_day\", \n            \"table day filter:\", \n            df_tips()[\"day\"].unique().tolist(), \n            multiple=True, \n            remove_button=True, \n            options={\"plugins\": [\"clear_button\"]}, \n        ) \n\n    # placeholder for joined dataframe\n    @reactive.calc\n    def df_tips():\n        # fmt: off\n        data = {\n            'total_bill': [\n                16.99, 10.34, 21.01, 23.68, 24.59,\n                25.29, 8.77, 26.88, 15.04, 14.78\n            ],\n            'tip': [\n                1.01, 1.66, 3.50, 3.31, 3.61,\n                4.71, 2.00, 3.12, 3.52, 3.00\n            ],\n            'sex': [\n                'Female', 'Male', 'Male', 'Male', 'Female',\n                'Male', 'Male', 'Male', 'Male', 'Female'\n            ],\n            'smoker': [\n                'No', 'No', 'No', 'No', 'Yes',\n                'No', 'No', 'Yes', 'No', 'Yes'\n            ],\n            'day': [\n                'Sun', 'Fri', 'Sun', 'Thu', 'Sun',\n                'Sun', 'Sat', 'Sat', 'Sat', 'Sat'\n            ],\n            'time': [\n                'Dinner', 'Dinner', 'Lunch', 'Dinner', 'Lunch',\n                'Dinner', 'Lunch', 'Dinner', 'Lunch', 'Dinner'\n            ],\n            'size': [2, 3, 3, 2, 4, 4, 2, 4, 2, 2]\n        }\n        # fmt: on\n\n        df = pd.DataFrame(data)\n        return df\n\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "posts/010-initial/index.html#add-another-filter-component",
    "href": "posts/010-initial/index.html#add-another-filter-component",
    "title": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application",
    "section": "Add Another Filter Component",
    "text": "Add Another Filter Component\nLet’s go add another filter. We’ll keep things simple for now, and add a filter for a column of the same data type, time, a categorical variable stored as a string.\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 650\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\napp_ui = ui.page_fixed(\n    ui.output_ui(\"table_day_filter\"),\n    ui.output_ui(\"table_time_filter\"),\n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n\n    # filtered dataframe from filters\n    @reactive.calc\n    def data_filtered():\n        df = df_tips()\n\n        if input.filter_day(): \n            df = df.loc[df[\"day\"].isin(input.filter_day())] \n\n        if input.filter_time(): \n            df = df.loc[df[\"time\"].isin(input.filter_time())] \n\n        return df\n\n    # dataframe to view in app\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\n    # table day filter\n    @render.ui\n    def table_day_filter():\n        return ui.input_selectize(\n            \"filter_day\",\n            \"table day filter:\",\n            df_tips()[\"day\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # table time filter\n    @render.ui\n    def table_time_filter():\n        return ui.input_selectize(\n            \"filter_time\",\n            \"table time filter:\",\n            df_tips()[\"time\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # placeholder for joined dataframe\n    @reactive.calc\n    def df_tips():\n        # fmt: off\n        data = {\n            'total_bill': [\n                16.99, 10.34, 21.01, 23.68, 24.59,\n                25.29, 8.77, 26.88, 15.04, 14.78\n            ],\n            'tip': [\n                1.01, 1.66, 3.50, 3.31, 3.61,\n                4.71, 2.00, 3.12, 3.52, 3.00\n            ],\n            'sex': [\n                'Female', 'Male', 'Male', 'Male', 'Female',\n                'Male', 'Male', 'Male', 'Male', 'Female'\n            ],\n            'smoker': [\n                'No', 'No', 'No', 'No', 'Yes',\n                'No', 'No', 'Yes', 'No', 'Yes'\n            ],\n            'day': [\n                'Sun', 'Fri', 'Sun', 'Thu', 'Sun',\n                'Sun', 'Sat', 'Sat', 'Sat', 'Sat'\n            ],\n            'time': [\n                'Dinner', 'Dinner', 'Lunch', 'Dinner', 'Lunch',\n                'Dinner', 'Lunch', 'Dinner', 'Lunch', 'Dinner'\n            ],\n            'size': [2, 3, 3, 2, 4, 4, 2, 4, 2, 2]\n        }\n        # fmt: on\n\n        df = pd.DataFrame(data)\n        return df\n\n\napp = App(app_ui, server)\n\n\nAs we add more components, we have to add code to three locations in the code base:\n\nA new @render.ui function within the server() logic\nCalling the @render.ui within app_ui\nFiltering the dataframe within the server() logic, in this case specifically in the data_filtered() @reactive.calc\n\nWe will also want to be able to control the sorting of the filter drop down. At the moment the elements are presented in the order they appear in the data. We may want to sort them alphabetically, or in these two component examples, sort them based on time.\n\n\n\n\n\n\nThings to fix\n\n\n\n\nDifferent filter components may want options presented in different orders"
  },
  {
    "objectID": "posts/010-initial/index.html#how-best-to-subset-the-data",
    "href": "posts/010-initial/index.html#how-best-to-subset-the-data",
    "title": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application",
    "section": "How (Best) to Subset the Data",
    "text": "How (Best) to Subset the Data\nCurrently, we are passing our filter contents into an .loc[] row subsetting call in a series of if statements. This works just fine in our current simple example, but we know that in the future there will be more filters.\nYou can always add another layer of abstraction to a program, and have your code run “in a single line of code”. But, each layer of abstraction will make the code harder to reason with since you will have to look up the definition elsewhere to keep everything in your head. \nOn the other hand, the current code using a sequence of if statements is fairly easy to reason with, you can see what is being checked along the way and how the data is filtered, and everything is right in front of you. However, we know that eventually this code will have many more if statements and you can make the case of cyclomatic complexity to at least abstract away the conditional if statements away that is doing the data filtering.\nWe now run into the first big implementation decision in our application, we could systematically filter the dataframes by the values in the filter in a series of if statements, however, it would make our current data_filtered() @reactive.cal very long and complicated. It would be easier to track a row ID so we can deal with all the filters and then the data_filtered() would only need to filter based on the ID. This helps abstract away the complexity of the filtering we’ll be doing, and potentially open us up for any more complicated filtering we would want to do later on.\n\nImplementation Idea 1: Use an ID Column\nIn pandas we could create an ID column by resetting and using the .index.\ndf.reset_index().rename(columns={\"index\": \"id\"})\nWe can check or track whether a data set has an ID column already, and if it doesn’t we can create one. But, we do not want to modify the original datasets in this manner, since it will be displayed and eventually save the extra column we created. It also would make the application less general as a template, since it will force other users to always have an explicit ID column.\n\n\nImplementation Idea 2: Track the Row Name (Pandas Index)\nA better way would be to track the the “row name” for each observation we want to keep. pandas does not have a “row name” but the .index can be used as one. We can assume since we are not processing any data, and this application is mainly serving as a data explorer, resetting the index of the dataframe and using the .index as a means to track the “row name” would be a good way to go.\n\n\nTest the Concept\nWe want to capture the index of the rows that match the filter, but when we are doing our final subsetting, we want to filter based on the .loc[] not .iloc[]. This will make sure as we make successive filters, and if the data gets scrambled, we are still pulling the correct row by the “row name” identifier.\n\ndf.sample(frac=1, random_state=42)\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n8\n15.04\n3.52\nMale\nNo\nSat\nLunch\n2\n\n\n1\n10.34\n1.66\nMale\nNo\nFri\nDinner\n3\n\n\n5\n25.29\n4.71\nMale\nNo\nSun\nDinner\n4\n\n\n0\n16.99\n1.01\nFemale\nNo\nSun\nDinner\n2\n\n\n7\n26.88\n3.12\nMale\nYes\nSat\nDinner\n4\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nLunch\n3\n\n\n9\n14.78\n3.00\nFemale\nYes\nSat\nDinner\n2\n\n\n4\n24.59\n3.61\nFemale\nYes\nSun\nLunch\n4\n\n\n3\n23.68\n3.31\nMale\nNo\nThu\nDinner\n2\n\n\n6\n8.77\n2.00\nMale\nNo\nSat\nLunch\n2\n\n\n\n\n\n\n\n\nidx = [6, 2, 1, 9]\n\nIf we look at the index values from .loc[], it matches the indices we want to keep.\n\ndf.sample(frac=1, random_state=42).loc[idx]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n6\n8.77\n2.00\nMale\nNo\nSat\nLunch\n2\n\n\n2\n21.01\n3.50\nMale\nNo\nSun\nLunch\n3\n\n\n1\n10.34\n1.66\nMale\nNo\nFri\nDinner\n3\n\n\n9\n14.78\n3.00\nFemale\nYes\nSat\nDinner\n2\n\n\n\n\n\n\n\nIf we use .iloc[] we won’t filter the rows we want. We can potentially even run into an out of bounds index with .iloc[].\n\ndf.sample(frac=1, random_state=42).iloc[idx]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n9\n14.78\n3.00\nFemale\nYes\nSat\nDinner\n2\n\n\n5\n25.29\n4.71\nMale\nNo\nSun\nDinner\n4\n\n\n1\n10.34\n1.66\nMale\nNo\nFri\nDinner\n3\n\n\n6\n8.77\n2.00\nMale\nNo\nSat\nLunch\n2\n\n\n\n\n\n\n\n\n\n\n\n\n\nA good idea\n\n\n\nTrack the index of the rows we want to filter."
  },
  {
    "objectID": "posts/010-initial/index.html#filter-based-on-index-label",
    "href": "posts/010-initial/index.html#filter-based-on-index-label",
    "title": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application",
    "section": "Filter Based on Index Label",
    "text": "Filter Based on Index Label\nOne of the other benefits of tracking the index for filtering is we do not need to filter out data with the dataframe boolean bitwise filtering with .loc[] and &. At the point of filtering, we can just use the list of index values.\n\ndf.loc[(df.time.isin([\"Dinner\"])) & (df['size'].isin([4]))]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n5\n25.29\n4.71\nMale\nNo\nSun\nDinner\n4\n\n\n7\n26.88\n3.12\nMale\nYes\nSat\nDinner\n4\n\n\n\n\n\n\n\nIf we can create just the container of index values, the code at the point of filtering would look much simpler. We would only need to track the row index labels when subsetting the final dataframe, and the logic for how the index values were generated can be abstracted away. This potentially opens us up for the ability to do any more complex filtering later on since only need to provide a list of index labels.\n\nidx = [5, 7] # creating this can be as complex as we need\ndf.loc[idx]\n\n\n\n\n\n\n\n\ntotal_bill\ntip\nsex\nsmoker\nday\ntime\nsize\n\n\n\n\n5\n25.29\n4.71\nMale\nNo\nSun\nDinner\n4\n\n\n7\n26.88\n3.12\nMale\nYes\nSat\nDinner\n4\n\n\n\n\n\n\n\n\nCreate List of Indices\nNow, how do we create this list of indices? If we were doing the filtering one column at a time, we would be using the & operator across all the filters (see the code example above). We now need the equivalent of this on a list. We will separately get a list of indices that match the filter, and then filter down each list for values that match. In set theory, this is an intersect.\nWe will create a new @reactive.calc called filter_idx() that will perform the same if statement checks as we did before. The difference now is at the point where the data is filtered, we only need to know that we’re filtering based on all the index labels that matched the filter.\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 650\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\napp_ui = ui.page_fixed(\n    ui.output_ui(\"table_day_filter\"),\n    ui.output_ui(\"table_time_filter\"),\n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n\n    @reactive.calc \n    def filter_idx(): \n        df = df_tips() \n        idx = set(df.index) \n\n        if input.filter_day(): \n            current_idx = df.loc[df[\"day\"].isin(input.filter_day())].index \n            idx = idx.intersection(set(current_idx)) \n\n        if input.filter_time(): \n            current_idx = df.loc[df[\"time\"].isin(input.filter_time())].index \n            idx = idx.intersection(set(current_idx)) \n\n        # convert to list because you get this error \n        # when passing into .loc[] \n        # TypeError: Passing a set as an indexer is not supported. Use a list instead. \n        return list(idx) \n\n\n    # filtered dataframe from filters\n    @reactive.calc\n    def data_filtered():\n        df = df_tips().loc[filter_idx()] \n        return df\n\n    # dataframe to view in app\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\n    # table day filter\n    @render.ui\n    def table_day_filter():\n        return ui.input_selectize(\n            \"filter_day\",\n            \"table day filter:\",\n            df_tips()[\"day\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # table time filter\n    @render.ui\n    def table_time_filter():\n        return ui.input_selectize(\n            \"filter_time\",\n            \"table time filter:\",\n            df_tips()[\"time\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # placeholder for joined dataframe\n    @reactive.calc\n    def df_tips():\n        # fmt: off\n        data = {\n            'total_bill': [\n                16.99, 10.34, 21.01, 23.68, 24.59,\n                25.29, 8.77, 26.88, 15.04, 14.78\n            ],\n            'tip': [\n                1.01, 1.66, 3.50, 3.31, 3.61,\n                4.71, 2.00, 3.12, 3.52, 3.00\n            ],\n            'sex': [\n                'Female', 'Male', 'Male', 'Male', 'Female',\n                'Male', 'Male', 'Male', 'Male', 'Female'\n            ],\n            'smoker': [\n                'No', 'No', 'No', 'No', 'Yes',\n                'No', 'No', 'Yes', 'No', 'Yes'\n            ],\n            'day': [\n                'Sun', 'Fri', 'Sun', 'Thu', 'Sun',\n                'Sun', 'Sat', 'Sat', 'Sat', 'Sat'\n            ],\n            'time': [\n                'Dinner', 'Dinner', 'Lunch', 'Dinner', 'Lunch',\n                'Dinner', 'Lunch', 'Dinner', 'Lunch', 'Dinner'\n            ],\n            'size': [2, 3, 3, 2, 4, 4, 2, 4, 2, 2]\n        }\n        # fmt: on\n\n        df = pd.DataFrame(data)\n        return df\n\n\napp = App(app_ui, server)\n\n\n\n\nIterative Improvement\nNow that we’ve modified the current code to roughly the parts we want, let’s make a few code improvements.\nFirst, our new filter_idx() @reactive.calc still relies on a series of if statements. We want to eventually perform filters across all or an arbitrary number of columns and filter components, so we’d want to do the same if logic in a for loop. We will need to track the column name as well as the filter id used by Shiny.\nSecond, the way filter_idx() was implemented has a lot of data type changes and isn’t obvious what what type the idx variable is because the initial type is changed in the return statement, and used as if its an .index value. This makes the code extremely hard to reason with and maintain. We are expecting an index value, the initial idx variable is stored as a set so we can run .intersection(), but the return type is a list.\n\nThe way filter_idx() was implemented wasn’t written this way for pedagogical purposes. I really did write the code in this manner in the initial implementation.\n\nThe first issue is fixed by using a for loop and creating a few accompanying variables. The second issue can be fixed by taking another look through the pandas API reference and noticing that we did not actually need to use .intersection() on a set, the index object also has an .intersection() method! This means we can implement filter_idx() using only index objects.\n\n\n\n\n\n\nA good idea\n\n\n\nDo not change the data type of your variables during an implementation.\n\n\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 650\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\napp_ui = ui.page_fixed(\n    ui.output_ui(\"table_day_filter\"),\n    ui.output_ui(\"table_time_filter\"),\n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n\n    @reactive.calc\n    def filter_idx():\n        df = df_tips()\n        idx = df.index\n\n        filters = [\"filter_day\", \"filter_time\"] \n        cols = [\"day\", \"time\"] \n\n        for fltr, col in zip(filters, cols): \n            if input[fltr](): \n                current_idx = df.loc[df[col].isin(input[fltr]())].index \n                idx = idx.intersection(current_idx) \n\n        return idx \n\n\n    # filtered dataframe from filters\n    @reactive.calc\n    def data_filtered():\n        df = df_tips().loc[filter_idx()]\n        return df\n\n    # dataframe to view in app\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\n    # table day filter\n    @render.ui\n    def table_day_filter():\n        return ui.input_selectize(\n            \"filter_day\",\n            \"table day filter:\",\n            df_tips()[\"day\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # table time filter\n    @render.ui\n    def table_time_filter():\n        return ui.input_selectize(\n            \"filter_time\",\n            \"table time filter:\",\n            df_tips()[\"time\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # placeholder for joined dataframe\n    @reactive.calc\n    def df_tips():\n        # fmt: off\n        data = {\n            'total_bill': [\n                16.99, 10.34, 21.01, 23.68, 24.59,\n                25.29, 8.77, 26.88, 15.04, 14.78\n            ],\n            'tip': [\n                1.01, 1.66, 3.50, 3.31, 3.61,\n                4.71, 2.00, 3.12, 3.52, 3.00\n            ],\n            'sex': [\n                'Female', 'Male', 'Male', 'Male', 'Female',\n                'Male', 'Male', 'Male', 'Male', 'Female'\n            ],\n            'smoker': [\n                'No', 'No', 'No', 'No', 'Yes',\n                'No', 'No', 'Yes', 'No', 'Yes'\n            ],\n            'day': [\n                'Sun', 'Fri', 'Sun', 'Thu', 'Sun',\n                'Sun', 'Sat', 'Sat', 'Sat', 'Sat'\n            ],\n            'time': [\n                'Dinner', 'Dinner', 'Lunch', 'Dinner', 'Lunch',\n                'Dinner', 'Lunch', 'Dinner', 'Lunch', 'Dinner'\n            ],\n            'size': [2, 3, 3, 2, 4, 4, 2, 4, 2, 2]\n        }\n        # fmt: on\n\n        df = pd.DataFrame(data)\n        return df\n\n\napp = App(app_ui, server)\n\n\nSince we made the mistake of mixing and converting data types, we can use Python type hints to make it clear to others what is happening with the data types, and also as a cue to ourself if we end up using types that we do not expect.\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 650\n\nimport pandas as pd\nfrom shiny import App, render, reactive, ui\n\napp_ui = ui.page_fixed(\n    ui.output_ui(\"table_day_filter\"),\n    ui.output_ui(\"table_time_filter\"),\n    ui.output_data_frame(\"render_df\"),\n)\n\ndef server(input, output, session):\n\n    @reactive.calc\n    def filter_idx() -&gt; pd.Index: \n        df = df_tips()\n        idx = df.index\n\n        filters = [\"filter_day\", \"filter_time\"]\n        cols = [\"day\", \"time\"]\n\n        for fltr, col in zip(filters, cols):\n            if input[fltr]():\n                current_idx = df.loc[df[col].isin(input[fltr]())].index\n                idx = idx.intersection(current_idx)\n\n        return idx\n\n\n    # filtered dataframe from filters\n    @reactive.calc\n    def data_filtered() -&gt; pd.DataFrame: \n        df = df_tips().loc[filter_idx()]\n        return df\n\n    # dataframe to view in app\n    @render.data_frame\n    def render_df():\n        return render.DataGrid(data_filtered())\n\n    # table day filter\n    @render.ui\n    def table_day_filter():\n        return ui.input_selectize(\n            \"filter_day\",\n            \"table day filter:\",\n            df_tips()[\"day\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # table time filter\n    @render.ui\n    def table_time_filter():\n        return ui.input_selectize(\n            \"filter_time\",\n            \"table time filter:\",\n            df_tips()[\"time\"].unique().tolist(),\n            multiple=True,\n            remove_button=True,\n            options={\"plugins\": [\"clear_button\"]},\n        )\n\n    # placeholder for joined dataframe\n    @reactive.calc\n    def df_tips():\n        # fmt: off\n        data = {\n            'total_bill': [\n                16.99, 10.34, 21.01, 23.68, 24.59,\n                25.29, 8.77, 26.88, 15.04, 14.78\n            ],\n            'tip': [\n                1.01, 1.66, 3.50, 3.31, 3.61,\n                4.71, 2.00, 3.12, 3.52, 3.00\n            ],\n            'sex': [\n                'Female', 'Male', 'Male', 'Male', 'Female',\n                'Male', 'Male', 'Male', 'Male', 'Female'\n            ],\n            'smoker': [\n                'No', 'No', 'No', 'No', 'Yes',\n                'No', 'No', 'Yes', 'No', 'Yes'\n            ],\n            'day': [\n                'Sun', 'Fri', 'Sun', 'Thu', 'Sun',\n                'Sun', 'Sat', 'Sat', 'Sat', 'Sat'\n            ],\n            'time': [\n                'Dinner', 'Dinner', 'Lunch', 'Dinner', 'Lunch',\n                'Dinner', 'Lunch', 'Dinner', 'Lunch', 'Dinner'\n            ],\n            'size': [2, 3, 3, 2, 4, 4, 2, 4, 2, 2]\n        }\n        # fmt: on\n\n        df = pd.DataFrame(data)\n        return df\n\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "posts/010-initial/index.html#final-initial-prototype",
    "href": "posts/010-initial/index.html#final-initial-prototype",
    "title": "Part I: Learning Software Engineering for Data Scientists - Building a Shiny Application",
    "section": "Final Initial Prototype",
    "text": "Final Initial Prototype\nOur final application is fairly simple, a couple of filter components that reactively subset a dataframe that gets shown in the app.\nInternally, we’ve made a few key implementation decisions:\n\nTrack the row index label\nCompute and use a pandas.Index for the dataframe filter\n\nWe’ve also left a few placeholders to help scale the application:\n\nStore the data as a @reactive.calc, df_tips()\nLoop through all the filters to track the .intersection()\n\nAnd saw how to watch out for certain code patters to avoid:\n\nChanging data types of a variable in a function\nChanging the expected return type of a variable\n\nIn the next part, we’ll add more filter components to the app and see what complexities arise when we work with more data types."
  }
]